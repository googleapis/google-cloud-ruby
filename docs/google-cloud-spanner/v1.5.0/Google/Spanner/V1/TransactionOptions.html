---
layout: yard_main
title: "Class: Google::Spanner::V1::TransactionOptions - Google"
css: 
  - /docs/css/style.css
  - /docs/css/common.css
  - /css/yard-main.css
js: 
  - /docs/js/app.js
  - /js/yard-main.js
---
<script type="text/javascript" charset="utf-8">
  pathId = "Google::Spanner::V1::TransactionOptions";
  relpath = '../../../';
</script>


<div class="nav-wrap">
  <iframe id="nav" src="../../../class_list.html?1"></iframe>
  <div id="resizer"></div>
</div>

<div id="main" tabindex="-1">
  <div id="header">
    <div id="menu">
  
    <a href="../../../_index.html">Index (T)</a> &raquo;
    <span class='title'><span class='object_link'><a href="../../../Google.html" title="Google (module)">Google</a></span></span> &raquo; <span class='title'><span class='object_link'><a href="../../Spanner.html" title="Google::Spanner (module)">Spanner</a></span></span> &raquo; <span class='title'><span class='object_link'><a href="../V1.html" title="Google::Spanner::V1 (module)">V1</a></span></span>
     &raquo; 
    <span class="title">TransactionOptions</span>
  
</div>

    <div id="search">
  
    <a class="full_list_link" id="class_list_link"
        href="../../../class_list.html">

        <svg width="24" height="24">
          <rect x="0" y="4" width="24" height="4" rx="1" ry="1"></rect>
          <rect x="0" y="12" width="24" height="4" rx="1" ry="1"></rect>
          <rect x="0" y="20" width="24" height="4" rx="1" ry="1"></rect>
        </svg>
    </a>
  
</div>
    <div class="clear"></div>
  </div>

  <div id="content"><h1>Class: Google::Spanner::V1::TransactionOptions
  
  
  
</h1>
<div class="box_info">
  
  <dl>
    <dt>Inherits:</dt>
    <dd>
      <span class="inheritName">Object</span>
      
        <ul class="fullTree">
          <li>Object</li>
          
            <li class="next">Google::Spanner::V1::TransactionOptions</li>
          
        </ul>
        <a href="#" class="inheritanceTree">show all</a>
      
    </dd>
  </dl>
  

  
  
  
  
  

  

  
  <dl>
    <dt>Defined in:</dt>
    <dd>lib/google/cloud/spanner/v1/doc/google/spanner/v1/transaction.rb</dd>
  </dl>
  
</div>

<h2>Overview</h2><div class="docstring">
  <div class="discussion">
    <p>= Transactions</p>

<p>Each session can have at most one active transaction at a time. After the
active transaction is completed, the session can immediately be
re-used for the next transaction. It is not necessary to create a
new session for each transaction.</p>

<p>= Transaction Modes</p>

<p>Cloud Spanner supports two transaction modes:</p>

<ol>
<li><p>Locking read-write. This type of transaction is the only way
 to write data into Cloud Spanner. These transactions rely on
 pessimistic locking and, if necessary, two-phase commit.
 Locking read-write transactions may abort, requiring the
 application to retry.</p></li>
<li><p>Snapshot read-only. This transaction type provides guaranteed
 consistency across several reads, but does not allow
 writes. Snapshot read-only transactions can be configured to
 read at timestamps in the past. Snapshot read-only
 transactions do not need to be committed.</p></li>
</ol>

<p>For transactions that only read, snapshot read-only transactions
provide simpler semantics and are almost always faster. In
particular, read-only transactions do not take locks, so they do
not conflict with read-write transactions. As a consequence of not
taking locks, they also do not abort, so retry loops are not needed.</p>

<p>Transactions may only read/write data in a single database. They
may, however, read/write data in different tables within that
database.</p>

<p>== Locking Read-Write Transactions</p>

<p>Locking transactions may be used to atomically read-modify-write
data anywhere in a database. This type of transaction is externally
consistent.</p>

<p>Clients should attempt to minimize the amount of time a transaction
is active. Faster transactions commit with higher probability
and cause less contention. Cloud Spanner attempts to keep read locks
active as long as the transaction continues to do reads, and the
transaction has not been terminated by
Commit or
Rollback.  Long periods of
inactivity at the client may cause Cloud Spanner to release a
transaction&#39;s locks and abort it.</p>

<p>Reads performed within a transaction acquire locks on the data
being read. Writes can only be done at commit time, after all reads
have been completed.
Conceptually, a read-write transaction consists of zero or more
reads or SQL queries followed by
Commit. At any time before
Commit, the client can send a
Rollback request to abort the
transaction.</p>

<p>=== Semantics</p>

<p>Cloud Spanner can commit the transaction if all read locks it acquired
are still valid at commit time, and it is able to acquire write
locks for all writes. Cloud Spanner can abort the transaction for any
reason. If a commit attempt returns +ABORTED+, Cloud Spanner guarantees
that the transaction has not modified any user data in Cloud Spanner.</p>

<p>Unless the transaction commits, Cloud Spanner makes no guarantees about
how long the transaction&#39;s locks were held for. It is an error to
use Cloud Spanner locks for any sort of mutual exclusion other than
between Cloud Spanner transactions themselves.</p>

<p>=== Retrying Aborted Transactions</p>

<p>When a transaction aborts, the application can choose to retry the
whole transaction again. To maximize the chances of successfully
committing the retry, the client should execute the retry in the
same session as the original attempt. The original session&#39;s lock
priority increases with each consecutive abort, meaning that each
attempt has a slightly better chance of success than the previous.</p>

<p>Under some circumstances (e.g., many transactions attempting to
modify the same row(s)), a transaction can abort many times in a
short period before successfully committing. Thus, it is not a good
idea to cap the number of retries a transaction can attempt;
instead, it is better to limit the total amount of wall time spent
retrying.</p>

<p>=== Idle Transactions</p>

<p>A transaction is considered idle if it has no outstanding reads or
SQL queries and has not started a read or SQL query within the last 10
seconds. Idle transactions can be aborted by Cloud Spanner so that they
don&#39;t hold on to locks indefinitely. In that case, the commit will
fail with error +ABORTED+.</p>

<p>If this behavior is undesirable, periodically executing a simple
SQL query in the transaction (e.g., +SELECT 1+) prevents the
transaction from becoming idle.</p>

<p>== Snapshot Read-Only Transactions</p>

<p>Snapshot read-only transactions provides a simpler method than
locking read-write transactions for doing several consistent
reads. However, this type of transaction does not support writes.</p>

<p>Snapshot transactions do not take locks. Instead, they work by
choosing a Cloud Spanner timestamp, then executing all reads at that
timestamp. Since they do not acquire locks, they do not block
concurrent read-write transactions.</p>

<p>Unlike locking read-write transactions, snapshot read-only
transactions never abort. They can fail if the chosen read
timestamp is garbage collected; however, the default garbage
collection policy is generous enough that most applications do not
need to worry about this in practice.</p>

<p>Snapshot read-only transactions do not need to call
Commit or
Rollback (and in fact are not
permitted to do so).</p>

<p>To execute a snapshot transaction, the client specifies a timestamp
bound, which tells Cloud Spanner how to choose a read timestamp.</p>

<p>The types of timestamp bound are:</p>

<ul>
<li>Strong (the default).

<ul>
<li>Bounded staleness.</li>
<li>Exact staleness.</li>
</ul></li>
</ul>

<p>If the Cloud Spanner database to be read is geographically distributed,
  stale read-only transactions can execute more quickly than strong
  or read-write transaction, because they are able to execute far
  from the leader replica.</p>

<p>Each type of timestamp bound is discussed in detail below.</p>

<p>=== Strong</p>

<p>Strong reads are guaranteed to see the effects of all transactions
that have committed before the start of the read. Furthermore, all
rows yielded by a single read are consistent with each other -- if
any part of the read observes a transaction, all parts of the read
see the transaction.</p>

<p>Strong reads are not repeatable: two consecutive strong read-only
transactions might return inconsistent results if there are
concurrent writes. If consistency across reads is required, the
reads should be executed within a transaction or at an exact read
timestamp.</p>

<p>See <span class='object_link'><a href="TransactionOptions/ReadOnly.html#strong-instance_method" title="Google::Spanner::V1::TransactionOptions::ReadOnly#strong (method)">TransactionOptions::ReadOnly#strong</a></span>.</p>

<p>=== Exact Staleness</p>

<p>These timestamp bounds execute reads at a user-specified
timestamp. Reads at a timestamp are guaranteed to see a consistent
prefix of the global transaction history: they observe
modifications done by all transactions with a commit timestamp &lt;=
the read timestamp, and observe none of the modifications done by
transactions with a larger commit timestamp. They will block until
all conflicting transactions that may be assigned commit timestamps
&lt;= the read timestamp have finished.</p>

<p>The timestamp can either be expressed as an absolute Cloud Spanner commit
timestamp or a staleness relative to the current time.</p>

<p>These modes do not require a &quot;negotiation phase&quot; to pick a
timestamp. As a result, they execute slightly faster than the
equivalent boundedly stale concurrency modes. On the other hand,
boundedly stale reads usually return fresher results.</p>

<p>See <span class='object_link'><a href="TransactionOptions/ReadOnly.html#read_timestamp-instance_method" title="Google::Spanner::V1::TransactionOptions::ReadOnly#read_timestamp (method)">TransactionOptions::ReadOnly#read_timestamp</a></span> and
<span class='object_link'><a href="TransactionOptions/ReadOnly.html#exact_staleness-instance_method" title="Google::Spanner::V1::TransactionOptions::ReadOnly#exact_staleness (method)">TransactionOptions::ReadOnly#exact_staleness</a></span>.</p>

<p>=== Bounded Staleness</p>

<p>Bounded staleness modes allow Cloud Spanner to pick the read timestamp,
subject to a user-provided staleness bound. Cloud Spanner chooses the
newest timestamp within the staleness bound that allows execution
of the reads at the closest available replica without blocking.</p>

<p>All rows yielded are consistent with each other -- if any part of
the read observes a transaction, all parts of the read see the
transaction. Boundedly stale reads are not repeatable: two stale
reads, even if they use the same staleness bound, can execute at
different timestamps and thus return inconsistent results.</p>

<p>Boundedly stale reads execute in two phases: the first phase
negotiates a timestamp among all replicas needed to serve the
read. In the second phase, reads are executed at the negotiated
timestamp.</p>

<p>As a result of the two phase execution, bounded staleness reads are
usually a little slower than comparable exact staleness
reads. However, they are typically able to return fresher
results, and are more likely to execute at the closest replica.</p>

<p>Because the timestamp negotiation requires up-front knowledge of
which rows will be read, it can only be used with single-use
read-only transactions.</p>

<p>See <span class='object_link'><a href="TransactionOptions/ReadOnly.html#max_staleness-instance_method" title="Google::Spanner::V1::TransactionOptions::ReadOnly#max_staleness (method)">TransactionOptions::ReadOnly#max_staleness</a></span> and
<span class='object_link'><a href="TransactionOptions/ReadOnly.html#min_read_timestamp-instance_method" title="Google::Spanner::V1::TransactionOptions::ReadOnly#min_read_timestamp (method)">TransactionOptions::ReadOnly#min_read_timestamp</a></span>.</p>

<p>=== Old Read Timestamps and Garbage Collection</p>

<p>Cloud Spanner continuously garbage collects deleted and overwritten data
in the background to reclaim storage space. This process is known
as &quot;version GC&quot;. By default, version GC reclaims versions after they
are one hour old. Because of this, Cloud Spanner cannot perform reads
at read timestamps more than one hour in the past. This
restriction also applies to in-progress reads and/or SQL queries whose
timestamp become too old while executing. Reads and SQL queries with
too-old read timestamps fail with the error +FAILED_PRECONDITION+.</p>


  </div>
</div>
<div class="tags">
  

</div><h2>Defined Under Namespace</h2>
<p class="children">
  
    
  
    
      <strong class="classes">Classes:</strong> <span class='object_link'><a href="TransactionOptions/ReadOnly.html" title="Google::Spanner::V1::TransactionOptions::ReadOnly (class)">ReadOnly</a></span>, <span class='object_link'><a href="TransactionOptions/ReadWrite.html" title="Google::Spanner::V1::TransactionOptions::ReadWrite (class)">ReadWrite</a></span>
    
  
</p>




  <h2>Instance Attribute Summary <small><a href="#" class="summary_toggle">collapse</a></small></h2>
  <ul class="summary">
    
      <li class="public ">
  <span class="summary_signature">
    
      <a href="#read_only-instance_method" title="#read_only (instance method)">#<strong>read_only</strong>  &#x21d2; Google::Spanner::V1::TransactionOptions::ReadOnly </a>
    

    
  </span>
  
  
  
    
    
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>Transaction will not write.</p>
</div></span>
  
</li>

    
      <li class="public ">
  <span class="summary_signature">
    
      <a href="#read_write-instance_method" title="#read_write (instance method)">#<strong>read_write</strong>  &#x21d2; Google::Spanner::V1::TransactionOptions::ReadWrite </a>
    

    
  </span>
  
  
  
    
    
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>Transaction may write.</p>
</div></span>
  
</li>

    
  </ul>





  <div id="instance_attr_details" class="attr_details">
    <h2>Instance Attribute Details</h2>
    
      
      <span id="read_only=-instance_method"></span>
      <div class="method_details first">
  <h3 class="signature first" id="read_only-instance_method">
  
    #<strong>read_only</strong>  &#x21d2; <tt><span class='object_link'><a href="TransactionOptions/ReadOnly.html" title="Google::Spanner::V1::TransactionOptions::ReadOnly (class)">Google::Spanner::V1::TransactionOptions::ReadOnly</a></span></tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>Returns Transaction will not write.</p>

<p>Authorization to begin a read-only transaction requires
+spanner.databases.beginReadOnlyTransaction+ permission
on the +session+ resource.</p>


  </div>
</div>
<div class="tags">
  
<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="TransactionOptions/ReadOnly.html" title="Google::Spanner::V1::TransactionOptions::ReadOnly (class)">Google::Spanner::V1::TransactionOptions::ReadOnly</a></span></tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>Transaction will not write.</p>

<p>Authorization to begin a read-only transaction requires
+spanner.databases.beginReadOnlyTransaction+ permission
on the +session+ resource.</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


248
249
250
251
252
253
254
255
256
257
258
259
260
261
262
263
264
265
266
267
268
269
270
271
272
273
274
275
276
277
278
279
280
281
282
283
284
285
286
287
288
289
290
291
292
293
294
295
296
297
298
299
300
301
302
303
304
305
306
307
308
309
310
311
312
313
314
315
316
317</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'lib/google/cloud/spanner/v1/doc/google/spanner/v1/transaction.rb', line 248</span>

<span class='kw'>class</span> <span class='const'><span class='object_link'><a href="" title="Google::Spanner::V1::TransactionOptions (class)">TransactionOptions</a></span></span>
  <span class='comment'># Message type to initiate a read-write transaction. Currently this
</span>  <span class='comment'># transaction type has no options.
</span>  <span class='kw'>class</span> <span class='const'><span class='object_link'><a href="TransactionOptions/ReadWrite.html" title="Google::Spanner::V1::TransactionOptions::ReadWrite (class)">ReadWrite</a></span></span><span class='semicolon'>;</span> <span class='kw'>end</span>

  <span class='comment'># Message type to initiate a read-only transaction.
</span>  <span class='comment'># @!attribute [rw] strong
</span>  <span class='comment'>#   @return [true, false]
</span>  <span class='comment'>#     Read at a timestamp where all previously committed transactions
</span>  <span class='comment'>#     are visible.
</span>  <span class='comment'># @!attribute [rw] min_read_timestamp
</span>  <span class='comment'>#   @return [Google::Protobuf::Timestamp]
</span>  <span class='comment'>#     Executes all reads at a timestamp &gt;= +min_read_timestamp+.
</span>  <span class='comment'>#
</span>  <span class='comment'>#     This is useful for requesting fresher data than some previous
</span>  <span class='comment'>#     read, or data that is fresh enough to observe the effects of some
</span>  <span class='comment'>#     previously committed transaction whose timestamp is known.
</span>  <span class='comment'>#
</span>  <span class='comment'>#     Note that this option can only be used in single-use transactions.
</span>  <span class='comment'>#
</span>  <span class='comment'>#     A timestamp in RFC3339 UTC \&quot;Zulu\&quot; format, accurate to nanoseconds.
</span>  <span class='comment'>#     Example: +&quot;2014-10-02T15:01:23.045123456Z&quot;+.
</span>  <span class='comment'># @!attribute [rw] max_staleness
</span>  <span class='comment'>#   @return [Google::Protobuf::Duration]
</span>  <span class='comment'>#     Read data at a timestamp &gt;= +NOW - max_staleness+
</span>  <span class='comment'>#     seconds. Guarantees that all writes that have committed more
</span>  <span class='comment'>#     than the specified number of seconds ago are visible. Because
</span>  <span class='comment'>#     Cloud Spanner chooses the exact timestamp, this mode works even if
</span>  <span class='comment'>#     the client&#39;s local clock is substantially skewed from Cloud Spanner
</span>  <span class='comment'>#     commit timestamps.
</span>  <span class='comment'>#
</span>  <span class='comment'>#     Useful for reading the freshest data available at a nearby
</span>  <span class='comment'>#     replica, while bounding the possible staleness if the local
</span>  <span class='comment'>#     replica has fallen behind.
</span>  <span class='comment'>#
</span>  <span class='comment'>#     Note that this option can only be used in single-use
</span>  <span class='comment'>#     transactions.
</span>  <span class='comment'># @!attribute [rw] read_timestamp
</span>  <span class='comment'>#   @return [Google::Protobuf::Timestamp]
</span>  <span class='comment'>#     Executes all reads at the given timestamp. Unlike other modes,
</span>  <span class='comment'>#     reads at a specific timestamp are repeatable; the same read at
</span>  <span class='comment'>#     the same timestamp always returns the same data. If the
</span>  <span class='comment'>#     timestamp is in the future, the read will block until the
</span>  <span class='comment'>#     specified timestamp, modulo the read&#39;s deadline.
</span>  <span class='comment'>#
</span>  <span class='comment'>#     Useful for large scale consistent reads such as mapreduces, or
</span>  <span class='comment'>#     for coordinating many reads against a consistent snapshot of the
</span>  <span class='comment'>#     data.
</span>  <span class='comment'>#
</span>  <span class='comment'>#     A timestamp in RFC3339 UTC \&quot;Zulu\&quot; format, accurate to nanoseconds.
</span>  <span class='comment'>#     Example: +&quot;2014-10-02T15:01:23.045123456Z&quot;+.
</span>  <span class='comment'># @!attribute [rw] exact_staleness
</span>  <span class='comment'>#   @return [Google::Protobuf::Duration]
</span>  <span class='comment'>#     Executes all reads at a timestamp that is +exact_staleness+
</span>  <span class='comment'>#     old. The timestamp is chosen soon after the read is started.
</span>  <span class='comment'>#
</span>  <span class='comment'>#     Guarantees that all writes that have committed more than the
</span>  <span class='comment'>#     specified number of seconds ago are visible. Because Cloud Spanner
</span>  <span class='comment'>#     chooses the exact timestamp, this mode works even if the client&#39;s
</span>  <span class='comment'>#     local clock is substantially skewed from Cloud Spanner commit
</span>  <span class='comment'>#     timestamps.
</span>  <span class='comment'>#
</span>  <span class='comment'>#     Useful for reading at nearby replicas without the distributed
</span>  <span class='comment'>#     timestamp negotiation overhead of +max_staleness+.
</span>  <span class='comment'># @!attribute [rw] return_read_timestamp
</span>  <span class='comment'>#   @return [true, false]
</span>  <span class='comment'>#     If true, the Cloud Spanner-selected read timestamp is included in
</span>  <span class='comment'>#     the {Google::Spanner::V1::Transaction Transaction} message that describes the transaction.
</span>  <span class='kw'>class</span> <span class='const'><span class='object_link'><a href="TransactionOptions/ReadOnly.html" title="Google::Spanner::V1::TransactionOptions::ReadOnly (class)">ReadOnly</a></span></span><span class='semicolon'>;</span> <span class='kw'>end</span>
<span class='kw'>end</span></pre>
    </td>
  </tr>
</table>
</div>
    
      
      <span id="read_write=-instance_method"></span>
      <div class="method_details ">
  <h3 class="signature " id="read_write-instance_method">
  
    #<strong>read_write</strong>  &#x21d2; <tt><span class='object_link'><a href="TransactionOptions/ReadWrite.html" title="Google::Spanner::V1::TransactionOptions::ReadWrite (class)">Google::Spanner::V1::TransactionOptions::ReadWrite</a></span></tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>Returns Transaction may write.</p>

<p>Authorization to begin a read-write transaction requires
+spanner.databases.beginOrRollbackReadWriteTransaction+ permission
on the +session+ resource.</p>


  </div>
</div>
<div class="tags">
  
<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="TransactionOptions/ReadWrite.html" title="Google::Spanner::V1::TransactionOptions::ReadWrite (class)">Google::Spanner::V1::TransactionOptions::ReadWrite</a></span></tt>)</span>
      
      
      
        &mdash;
        <div class='inline'><p>Transaction may write.</p>

<p>Authorization to begin a read-write transaction requires
+spanner.databases.beginOrRollbackReadWriteTransaction+ permission
on the +session+ resource.</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


248
249
250
251
252
253
254
255
256
257
258
259
260
261
262
263
264
265
266
267
268
269
270
271
272
273
274
275
276
277
278
279
280
281
282
283
284
285
286
287
288
289
290
291
292
293
294
295
296
297
298
299
300
301
302
303
304
305
306
307
308
309
310
311
312
313
314
315
316
317</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'lib/google/cloud/spanner/v1/doc/google/spanner/v1/transaction.rb', line 248</span>

<span class='kw'>class</span> <span class='const'><span class='object_link'><a href="" title="Google::Spanner::V1::TransactionOptions (class)">TransactionOptions</a></span></span>
  <span class='comment'># Message type to initiate a read-write transaction. Currently this
</span>  <span class='comment'># transaction type has no options.
</span>  <span class='kw'>class</span> <span class='const'><span class='object_link'><a href="TransactionOptions/ReadWrite.html" title="Google::Spanner::V1::TransactionOptions::ReadWrite (class)">ReadWrite</a></span></span><span class='semicolon'>;</span> <span class='kw'>end</span>

  <span class='comment'># Message type to initiate a read-only transaction.
</span>  <span class='comment'># @!attribute [rw] strong
</span>  <span class='comment'>#   @return [true, false]
</span>  <span class='comment'>#     Read at a timestamp where all previously committed transactions
</span>  <span class='comment'>#     are visible.
</span>  <span class='comment'># @!attribute [rw] min_read_timestamp
</span>  <span class='comment'>#   @return [Google::Protobuf::Timestamp]
</span>  <span class='comment'>#     Executes all reads at a timestamp &gt;= +min_read_timestamp+.
</span>  <span class='comment'>#
</span>  <span class='comment'>#     This is useful for requesting fresher data than some previous
</span>  <span class='comment'>#     read, or data that is fresh enough to observe the effects of some
</span>  <span class='comment'>#     previously committed transaction whose timestamp is known.
</span>  <span class='comment'>#
</span>  <span class='comment'>#     Note that this option can only be used in single-use transactions.
</span>  <span class='comment'>#
</span>  <span class='comment'>#     A timestamp in RFC3339 UTC \&quot;Zulu\&quot; format, accurate to nanoseconds.
</span>  <span class='comment'>#     Example: +&quot;2014-10-02T15:01:23.045123456Z&quot;+.
</span>  <span class='comment'># @!attribute [rw] max_staleness
</span>  <span class='comment'>#   @return [Google::Protobuf::Duration]
</span>  <span class='comment'>#     Read data at a timestamp &gt;= +NOW - max_staleness+
</span>  <span class='comment'>#     seconds. Guarantees that all writes that have committed more
</span>  <span class='comment'>#     than the specified number of seconds ago are visible. Because
</span>  <span class='comment'>#     Cloud Spanner chooses the exact timestamp, this mode works even if
</span>  <span class='comment'>#     the client&#39;s local clock is substantially skewed from Cloud Spanner
</span>  <span class='comment'>#     commit timestamps.
</span>  <span class='comment'>#
</span>  <span class='comment'>#     Useful for reading the freshest data available at a nearby
</span>  <span class='comment'>#     replica, while bounding the possible staleness if the local
</span>  <span class='comment'>#     replica has fallen behind.
</span>  <span class='comment'>#
</span>  <span class='comment'>#     Note that this option can only be used in single-use
</span>  <span class='comment'>#     transactions.
</span>  <span class='comment'># @!attribute [rw] read_timestamp
</span>  <span class='comment'>#   @return [Google::Protobuf::Timestamp]
</span>  <span class='comment'>#     Executes all reads at the given timestamp. Unlike other modes,
</span>  <span class='comment'>#     reads at a specific timestamp are repeatable; the same read at
</span>  <span class='comment'>#     the same timestamp always returns the same data. If the
</span>  <span class='comment'>#     timestamp is in the future, the read will block until the
</span>  <span class='comment'>#     specified timestamp, modulo the read&#39;s deadline.
</span>  <span class='comment'>#
</span>  <span class='comment'>#     Useful for large scale consistent reads such as mapreduces, or
</span>  <span class='comment'>#     for coordinating many reads against a consistent snapshot of the
</span>  <span class='comment'>#     data.
</span>  <span class='comment'>#
</span>  <span class='comment'>#     A timestamp in RFC3339 UTC \&quot;Zulu\&quot; format, accurate to nanoseconds.
</span>  <span class='comment'>#     Example: +&quot;2014-10-02T15:01:23.045123456Z&quot;+.
</span>  <span class='comment'># @!attribute [rw] exact_staleness
</span>  <span class='comment'>#   @return [Google::Protobuf::Duration]
</span>  <span class='comment'>#     Executes all reads at a timestamp that is +exact_staleness+
</span>  <span class='comment'>#     old. The timestamp is chosen soon after the read is started.
</span>  <span class='comment'>#
</span>  <span class='comment'>#     Guarantees that all writes that have committed more than the
</span>  <span class='comment'>#     specified number of seconds ago are visible. Because Cloud Spanner
</span>  <span class='comment'>#     chooses the exact timestamp, this mode works even if the client&#39;s
</span>  <span class='comment'>#     local clock is substantially skewed from Cloud Spanner commit
</span>  <span class='comment'>#     timestamps.
</span>  <span class='comment'>#
</span>  <span class='comment'>#     Useful for reading at nearby replicas without the distributed
</span>  <span class='comment'>#     timestamp negotiation overhead of +max_staleness+.
</span>  <span class='comment'># @!attribute [rw] return_read_timestamp
</span>  <span class='comment'>#   @return [true, false]
</span>  <span class='comment'>#     If true, the Cloud Spanner-selected read timestamp is included in
</span>  <span class='comment'>#     the {Google::Spanner::V1::Transaction Transaction} message that describes the transaction.
</span>  <span class='kw'>class</span> <span class='const'><span class='object_link'><a href="TransactionOptions/ReadOnly.html" title="Google::Spanner::V1::TransactionOptions::ReadOnly (class)">ReadOnly</a></span></span><span class='semicolon'>;</span> <span class='kw'>end</span>
<span class='kw'>end</span></pre>
    </td>
  </tr>
</table>
</div>
    
  </div>


</div>

  <div id="footer">
  <ul class="footer-links">
    <li>
      <a href="https://github.com/GoogleCloudPlatform/google-cloud-ruby" title="Google Cloud on Github">
        <img src="/google-cloud-ruby/img/icon-link-github.svg" alt="GitHub icon"> GitHub
      </a>
    </li>
    <li>
      <a href="https://github.com/GoogleCloudPlatform/google-cloud-ruby/issues" title="Google Cloud issues on Github">
        <img src="/google-cloud-ruby/img/icon-link-github.svg" alt="GitHub icon"> Issues
      </a>
    </li>
    <li>
      <a href="http://stackoverflow.com/questions/tagged/google-cloud-ruby" title="Google Cloud on StackOverflow">
      <img src="/google-cloud-ruby/img/icon-link-stackoverflow.svg" alt="StackOverflow icon"> StackOverflow
    </a>
    </li>
    <li>
      <a href="http://rubygems.org/gems/google-cloud" title="Google Cloud on RubyGems">
        <img src="/google-cloud-ruby/img/icon-link-package-manager.svg" alt="RubyGems icon"> RubyGems
      </a>
    </li>
  </ul>

  <p>
    Documentation generated by <a href="http://yardoc.org" title="Yay! A Ruby Documentation Tool">yard</a>.
  </p>
</div>

</div>
